# Замыкание функции
Функция это изолированная подпрограмма. Которая запускается в своей области оперативной памяти. Видит только те переменные которая создала сама. Когда функция завершается, то переменные которые она видела, стираются.

При этом функция в JavaScript, видит те переменные, которые расположены не только внутри неё но и выше неё, у родителя (в родительской области видимости).

Функции в JS видят переменные у родителя по замыканию.

## Зоны видимости переменных
- глобальная зона видимости
- зона видимости внутри функции
- зона видимости внутри функции, которая находится внутри другой функции и т.д.
- зона видимости внутри цикла, если используется `let`

Видимость переменных:

    let x = 1;
    function some(){
      let x = 10;

      function other(){
        let x = 100;
        console.log(x); // 100
      }

      other(); // 100
      console.log(x); // 10
    }
    some(); // 10

Консоль выведет `100` и `10`, если убрать `let` у втрого присваивания `x`, то консоль выведет `100` и `100`. Функция видит переменные у родителя по замыканию.

## После заверешния функции она удаляет все свои переменные

    function init(){
      let x = 100;
    }

    init(); // Функция отработала и удалила все свои переменные

Тут после вывода в консоли `init function is over`, через три секунды появится 100, хотя функция `init()` уже завершилась.

    function init() {
      let x = 100;

      setTimeout(function() {
        console.log(x);
      }, 3000);
    }

    init();
    console.log('init function is over');

setTimeout не тормозит завершение функции init, она работает асинхронно. Жизнь переменной `x` длится столько сколько живет дочерние функции её видящие. Дочерние функции замыкают срок жизни переменным родителя. После завершения работы, сама функция init не удаляется, а продолжает жить в глобальной области видимости, потому что к ней могут обратиться.

Рассмотрим код:

    window.addEventListener('load', function() {
      let text = document.querySelector('.text');
      text.innerHTML = 'Имя';

      text.addEventListener('click', function() {
        text.innerHTML += 1; // Имя11111
      });

      text.addEventListener('click', function() {
        text.innerHTML += 2; // Имя1212121212
      });
    });

Обработчик события loаd это функция которая отработает и стерет перменную text. Но из-за дочерних функци, обработчиков события click, переменная text живет постоянно. Причем продлевается жизнь всем переменным родителя. Продление жизни переменным родителя и есть замыкание.

Замыкания в JavaScript позволяют создавать общие переменные, например для счетчиков.

## При наведении мыши на текст, цвет текста меняется
Также при нажатии по кнопке в массив добавляется новый цвет.  
Функция `load` завершится быстро, а `colors` из-за замыкания будет доступен для функций (обработчиков событий) `mouseenter` и `click` постоянно.

    window.addEventListener('load', function() {
      let div = document.querySelector('.some');
      let btn = document.querySelector('.btnColor');
      let colors = ['#f00', '#ff0', '#0f0'];

      div.addEventListener('mouseenter', function() {
        let num = Math.floor(Math.random() * colors.length);
        div.style.color = colors[num];
      });

      btn.addEventListener('click', function() {
        colors.push('#f90');
      });
    });

## Итог
За счет замыканий мы можем создавать переменные которые долго живут, даже если функция в которой содержится данная переменная уже отработана. Эти переменные являются общими для разных функций. Если бы замыканий в JavaScript не было то тогда бы пришлось использовать ООП где методы видят свойства класса.

При этом стоит помнить что большая вложенность функций и множество общих переменных может запуать программиста и затруднить яитаемость кода.
